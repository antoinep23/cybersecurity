# RSA Implementation

A basic implementation of the RSA cryptographic algorithm in Python.

## Overview

This implementation provides the core RSA functionality including:

- âœ… Key generation with user-defined prime numbers
- ğŸ” Message encryption using the public key
- ğŸ”“ Message decryption using the private key

## âš™ï¸ Technical Details

### ğŸ”‘ Key Generation

- Uses two prime numbers `p` and `q` to compute the modulus: n = p \* q

- Calculates Euler's totient function: Ï†(n) = (p - 1) \* (q - 1)

- Uses a fixed public exponent `e = 65537` (a common choice in RSA)

- Computes the private exponent `d` using the modular inverse:  
  \[
  d \equiv e^{-1} \mod \varphi(n)
  \]

### ğŸ” Encryption / ğŸ”“ Decryption

- Messages are:
  - Encoded to UTF-8 bytes
  - Converted to integers for computation
- **Encryption**:
  \[
  c \equiv m^e \mod n
  \]
- **Decryption**:
  \[
  m \equiv c^d \mod n
  \]
- Results are decoded back into UTF-8 strings

---

## âš ï¸ Important Limitations

> **This implementation is for educational purposes only and lacks critical security features.**

- âŒ **No padding scheme**  
  (e.g. PKCS#1 v1.5 â€” necessary for real-world security)
- âŒ **Message size limitations**  
  Messages must be smaller than the modulus `n`
- âŒ **No random prime generation**  
  Requires manual input of prime numbers
- âŒ **Basic error handling**  
  Limited validation and error reporting

---

## Usage

```python
# Generate keys with two prime numbers
keys = generate_rsa_keys(p=22079, q=22091)

# Encrypt a message
ciphertext = rsa_encrypt("Hello World", keys["public_key"])

# Decrypt the message
plaintext = rsa_decrypt(ciphertext, keys["private_key"])
```
